//: [Previous](@previous)
//:
//: # O(log N)
//:
//: Логарифмическая `O(log n)`: сложность функций логарифмически минимизируется, когда размер ее входных данных N растет.
//:
//: Такая сложность характерна для алгоритма, где на каждой итерации берется половина элементов, например, алгоритм бинарного поиска.
//: Чтобы было проще понять, откуда берется log и что он означает, давайте вспомним такой алгоритм, как бинарный поиск. Он работает на заранее упорядоченном массиве.
//:
//: - Взять середину массива;
//: - Сравнить число с серединой. Если оно меньше середины, то ищем в левой части массива. Если число больше, ищем в правой части массива;
//: - Повторим проверку для подмассива;
//: - Закончим, если найдем нужный элемент или длина подмассива будет 1.

func binarySearch<T: Comparable>(items: [T], target: T) -> Int? {
	guard !items.isEmpty else { return nil }
	
	var start = 0
	var end = items.count - 1
	while start <= end {
		let middleIndex = (start + end) / 2
		let middleValue = items[middleIndex]
		
		if middleValue == target {
			return middleIndex
		} else if target < middleValue {
			// ищем в левой части массива
			end = middleIndex - 1
		} else {
			// ищем в левой части массива
			start = middleIndex + 1
		}
	}
	
	return nil
}

//: Итак, из-за того, что мы каждую итерацию пробегаем только половину массива, получается, что во второй итерации мы обрабатываем `n/2`, а в третьей `n/4`...
//:
//: Допустим, что наш массив размером в 64 элементов, тогда наши итерации будут таковыми:
//:
//: - n = 64 // 2^6
//: - n = 32 // 2^5
//: - n = 16 // 2^4
//: - n = 8  // 2^3
//: - n = 4  // 2^2
//: - n = 2  // 2^1
//: - n = 1  // 2^0
//:
//: Так как `2^k = n`, то результат выглядит как необходимость выполнения `k = log2(n)` операций.
//:
//: `O(log n)` такую сложность имеет алгоритм «бинарный поиск».
//:
//: [Next](@next)
