//: [Previous](@previous)
//:
//: # O(n)
//:
//: Линейное время `O(n)`: функция работает за линейное время, потому что ее скорость зависит от размера входных данных.
//:
//: Когда каждый элемент в массиве должен быть обработан, чтобы функция достигла своей цели, мы должны пройти по всему массиву. Это означает, что функция становится менее эффективной по мере увеличения количества элементов.
//:
//: Рассмотрим пример рекурсивной функции, которая складывает числа:

func sumSequence(_ n: Int) -> Int {
	if n == 1 { return 1 }
	return n + sumSequence(n - 1)
}

//: Очевидно, что у этого алогритма `sumSequence` сложность описывается как `O(n)`, так как чем больше число N, тем большее количество раз функция будет вызывать саму себя.
//:
//: Мы можем развернуть рекурсию и сделать тоже самое, но уже без рекурсивного вызова:

func sum(_ a: Int, _ b: Int) -> Int {
	a + b
}

func sumSequence2(_ n: Int) -> Int {
	var total = 0
	for i in 0...n {
		total = sum(total, i)
	}
	return total
}

//: Сложность же функции `sum`, это `O(1)`, так как тут всего лишь сложение 2х чисел и оно всегда будет требовать одинаковых затрат. А вот сложность `sumSequence` как и при рекурсии, тоже `O(n)`, так как нам придется пройтись в цикле по всем n элементам.

let array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

for item in array {
	print(item)
}

for item in array {
	print(item)
}

//: Тут сложность `O(n + n) = O(n)`
//: Перебор коллекции это `O(n)`
//:
//: [Next](@next)
